// Generated by LiveScript 1.4.0
(function(){
  var _, bus, nextId, Computation, Hacktiv;
  _ = require('underscore');
  bus = require('./Bus');
  nextId = 1;
  Computation = (function(){
    Computation.displayName = 'Computation';
    var prototype = Computation.prototype, constructor = Computation;
    prototype.id = null;
    prototype.deps = [];
    function Computation(f){
      this.f = f;
      this.id = nextId++;
      this.Record();
    }
    prototype.Record = function(){
      if (!Hacktiv._.replay) {
        this.StartRecord();
      }
      this.f();
      if (!Hacktiv._.replay) {
        return this.StopRecord();
      }
    };
    prototype.StartRecord = function(){
      var i$, ref$, len$, dep, this$ = this;
      if (this.recorder != null) {
        return;
      }
      Hacktiv._.AddComput(this);
      for (i$ = 0, len$ = (ref$ = this.deps).length; i$ < len$; ++i$) {
        dep = ref$[i$];
        dep.dep.removeListener('changed', dep.handler);
      }
      this.deps = [];
      this.recorder = function(dep){
        var handler;
        handler = function(dep){
          Hacktiv._.replay = true;
          this$.f();
          return Hacktiv._.replay = false;
        };
        dep.on('changed', handler);
        if (!in$(dep, this$.deps)) {
          return this$.deps.push({
            dep: dep,
            handler: handler
          });
        }
      };
      return bus.on('depends', this.recorder);
    };
    prototype.Pause = function(){
      if (this.recorder == null) {
        return;
      }
      return bus.removeListener('depends', this.recorder);
    };
    prototype.Resume = function(){
      if (this.recorder == null) {
        return;
      }
      return bus.on('depends', this.recorder);
    };
    prototype.StopRecord = function(){
      if (this.recorder == null) {
        return;
      }
      bus.removeListener('depends', this.recorder);
      this.recorder = null;
      return Hacktiv._.Pop();
    };
    prototype.Stop = function(){
      var i$, ref$, len$, dep;
      for (i$ = 0, len$ = (ref$ = this.deps).length; i$ < len$; ++i$) {
        dep = ref$[i$];
        dep.dep.removeListener('changed', dep.handler);
      }
      return Hacktiv._.Remove(this);
    };
    return Computation;
  }());
  module.exports = Computation;
  Hacktiv = require('./Hacktiv');
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
